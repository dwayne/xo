#!/usr/bin/env ruby
#
# A Tic-tac-toe game client based on xo.

require 'xo'
include XO

AUTHOR = "Dwayne Crooks"
EMAIL  = "me@dwaynecrooks.com"

PROMPT = "> "

class Player

  def moves(grid, turn)
    raise NotImplementedError
  end

  private

    def all_open_moves(grid)
      moves = []

      grid.each_open do |r, c|
        moves << [r, c]
      end

      moves
    end

    def all_smart_moves(grid, turn)
      AI::Minimax.instance.moves(grid, turn)
    end
end

class Easy < Player

  def moves(grid, turn)
    all_open_moves(grid)
  end
end

class Medium < Player

  def moves(grid, turn)
    smart_moves = all_smart_moves(grid, turn)
    dumb_moves = all_open_moves(grid) - smart_moves

    dumb_moves.empty? ? smart_moves : (rand < 0.75 ? smart_moves : dumb_moves)
  end
end

class Hard < Player

  def moves(grid, turn)
    all_smart_moves(grid, turn)
  end
end

def welcome
  heading = "Welcome to xo! A Tic-tac-toe game client created by #{AUTHOR}."

  puts heading
  puts "=" * heading.length
  puts

  puts "NOTE: You can exit the game at anytime by pressing CTRL-C."
  puts
end

def display_prompt
  print PROMPT
end

def display_start
  puts
  puts "Starting..."
  puts
end

def ask_for_difficulty_level
  puts "Please select your difficulty level:"
  puts "1. Easy"
  puts "2. Medium"
  puts "3. Hard"

  get_option({ '1' => Easy, '2' => Medium, '3' => Hard })
end

def ask_for_token
  puts "Do you want to play as x or o?"

  get_option({ 'x' => Grid::X, 'o' => Grid::O })
end

def ask_to_play_first
  puts "Do you want to play first (y or n)?"

  get_option({ 'y' => true, 'n' => false })
end

def ask_to_play_again
  puts "Do you want to play again (y or n)?"

  get_option({ 'y' => true, 'n' => false })
end

def get_option(options)
  display_prompt

  selection = gets.chomp

  if options.key?(selection)
    options[selection]
  else
    get_option(options)
  end
end

def play(engine, ai)
  puts engine.grid
  puts
  puts "Your move (enter in the format r, c):"

  r, c = get_move

  event = engine.play(r, c).last_event

  case event[:name]
  when :next_turn
    puts
    puts engine.grid
    puts

    ai_play(engine, ai)
  when :game_over
    puts

    case event[:type]
    when :winner
      puts "Congratulations! You won."
    when :squashed
      puts "Sorry! Game squashed."
    end

    puts
  when :invalid_move
    puts
    puts "Sorry! You cannot make that move."

    case event[:type]
    when :occupied
      puts "That position is occupied."
      puts
    when :out_of_bounds
      puts "That position is not on the board."
      puts
    end

    play(engine, ai)
  end
end

def get_move
  display_prompt

  position = gets.chomp.split(',').map(&:strip).map(&:to_i)

  if position.length == 2
    position
  else
    get_move
  end
end

def ai_play(engine, ai)
  puts "Waiting for the computer to play..."

  r, c = ai.moves(engine.grid, engine.turn).shuffle[0]

  event = engine.play(r, c).last_event

  puts "The computer played at #{r}, #{c}."
  puts

  case event[:name]
  when :next_turn
    play(engine, ai)
  when :game_over
    puts engine.grid
    puts

    case event[:type]
    when :winner
      puts "Sorry! You lost."
    when :squashed
      puts "Sorry! Game squashed."
    end

    puts
  end
end

welcome

level      = ask_for_difficulty_level
player     = ask_for_token
play_first = ask_to_play_first

ai = level.new
engine = Engine.new

display_start

if play_first
  engine.start(player)
  play(engine, ai)
else
  engine.start(Grid.other_token(player))
end

while engine.state != :game_over
  player == engine.turn ? play(engine, ai) : ai_play(engine, ai)
end

play_again = ask_to_play_again

while play_again
  display_start

  event = engine.last_event

  case event[:type]
  when :winner
    engine.continue_playing(engine.turn)
  when :squashed
    engine.continue_playing(engine.next_turn)
  end

  while engine.state != :game_over
    player == engine.turn ? play(engine, ai) : ai_play(engine, ai)
  end

  play_again = ask_to_play_again
end

puts "Thank you for playing."
puts "Bye!"
